---
title: "Statistical Computing - 2nd Peer Review"
author: "Ndabezinhle Maphumulo"
format: html
editor: visual
---

## Question 1

```{r}
library(foreach)

x <- foreach(i = 1:100) %do% rexp(50, rate = 1)
x <- matrix(unlist(x), nrow=100)

mean_x <- round(apply(x, 2, mean), 3)
variance_x <- round(apply(x, 2, var), 3)

mean_variance <- rbind(mean_x, variance_x)
knitr::kable(data.frame(mean_x, variance_x), digits = 4, 
             col.names = c("mean", "variance"))
```

## Question 2

```{r}
library(MASS)        
library(doParallel) 
library(foreach)     

# register a cluster:
cl <- makeCluster(3)
registerDoParallel(cl)

N <- 1000
gal <- galaxies
# FOREACH LOOP IN PARALLEL
# Function to perform bootstrap sampling and calculate median
# System time for parallel bootstrap computation
parallel_time <- system.time({
  parallel_medians <- foreach(i = 1:N, .combine = c, .packages = 'MASS') %dopar% {
    median(sample(gal, length(gal), replace = TRUE))
  }
})
    
# Stop cluster
stopCluster(cl)

cat("Parallel time\n")
(parallel_time)


serial_time <- system.time({
  parallel_medians <- foreach(i = 1:N, .combine = c, .packages = 'MASS') %do% {
    median(sample(gal, length(gal), replace = TRUE))
  }
})

cat("Serial time\n")
(serial_time)
```
Serial processing was faster than parallel computing. That may be because bootstrap samples are relatively small


## Question 3

```{r}
set.seed(1)
n<-50
u<- rexp(n,rate=1)
mean.1 <- mean(u)
mean.1

B<-1000
c1 <- c()
c2 <- c()

bstr <- matrix(0,nrow=1000,ncol=n)
for (i in 1:B) {
  samp<-sample(u,size=n,replace=TRUE)
  bstr[i,]<-samp
c1[i]<-quantile(bstr[i,],probs=0.025)
c2[i]<-quantile(bstr[i,],probs=0.975)
}

count <- 0
for (i in 1:B) {
  if (c1[i]<= mean.1 & mean.1 <= c2[i]) {
     count = count + 1
  }
}

coverage <- count/B
coverage
```

## Question 4

```{r}

library(foreach)

set.seed(1234)
result <- foreach(i = 1:3) %do% {
  it <- irnorm(5)
  nextElem(it)
  nextElem(it)
  nextElem(it)

}

for (i in 1:3) {
  maxi <- max(result[[i]])
  print(maxi)
}
```

## Question 5

```{r}
library(parallel)

set.seed(1234)
result <- function() {
  it <- irnorm(5)
  nextElem(it)
  nextElem(it)
  nextElem(it)
  nextElem(it)
  nextElem(it)
}

# For the foreach
system.time({
result1 <- foreach(i = 1:3) %do% {
  result()
}

for (i in 1:3) {
  maxi <- max(result1[[i]])
  print(maxi)
}
})

#For the parLapply
cl <- makeCluster(3)
clusterExport(cl, "result")
clusterEvalQ(cl, library(iterators))

system.time({
parL <- parLapply(cl, 1:3, function(i){
  result()

})

for (i in 1:3) {
  maxi <- max(parL[[i]])
  print(maxi)
}
})

# for replicate
set.seed(1234)
system.time({
result2 <- replicate(n = 3, result())

for (i in 1:3) {
  maxi <- max(result2[,i])
  print(maxi)
}
})
```
